<h1 id="is-async-worthwhile-">Is async worthwhile?</h1>
<p>One of the main motivations for building Piccolo was the lack of options for an asyncio ORM.</p>
<h2 id="what-is-asyncio-">What is asyncio?</h2>
<p>asyncio is a library added in Python 3, to provide an event loop implementation in the standard library.</p>
<p>Prior to this, each framework that implemented non-blocking IO via an event loop had their own event loop implementation, limiting interoperability (Twisted and Tornado being by far the most well known).</p>
<h2 id="why-is-an-event-loop-useful-">Why is an event loop useful?</h2>
<p>An event loop is one approach to concurrency. The others are:</p>
<ul>
<li>threads</li>
<li>processes</li>
<li>greenlets (lightweight, non-system threads)</li>
<li>implicit yielding (gevent, and eventlet)</li>
</ul>
<p>Traditionally, each unit of work which needs to operate concurrently would be assigned to a separate process or thread. Threads and processes are operating system constructs, and are expensive to create. It&#39;s up to the operating system when it schedules If a program requires thousands of threads ... It&#39;s also very easy to trash a program which operates this way - each connection takes up operating system resources, making a DOS attack trivial.</p>
<h2 id="what-does-asyncio-give-us-">What does asyncio give us?</h2>
<p>Asyncio provides</p>
<h2 id="does-my-corner-shop-s-website-need-asyncio-">Does my corner shop&#39;s website need asyncio?</h2>
<p>Most small websites won&#39;t get enough traffic to stress even the smallest of servers.</p>
<p>However, for building websites or APIs with at least moderate scale, there are real benefits to using non-blocking IO.</p>
<p>Asyncio will help improve the throughput of a Python application. This means that a given VM can handle more traffic, which can result in real cost savings.</p>
<h2 id="is-asyncio-all-about-speed-">Is asyncio all about speed?</h2>
<p>Non-blocking IO won&#39;t make your website faster when under small load. For example, when only dealing with one sequential request at a time.</p>
<p>However, it does improve the throughput of a website, so under high load, a user&#39;s request will be queued for less time, and they&#39;ll receive a response faster.</p>
<p>An interesting side effect of asyncio is it got library authors thinking about performance. By using efficient HTTP parsing, and Cython-ising slow parts, many asyncio libraries are actually faster than synchronous alternatives, but this isn&#39;t due to asyncio itself.</p>
<h2 id="how-much-time-does-python-spend-waiting-on-a-database-">How much time does Python spend waiting on a database?</h2>
<p>Even a simple database operation takes in the order of milliseconds (10^-3) to execute.</p>
<p>This doesn&#39;t include the network lag when talking to a remote database, and also additional overhead such as authentication and encryption.</p>
<p>Python isn&#39;t a fast language, but basic Python operations take in the order of microseconds (10^-6).</p>
<p>So there is time for Python to do meaningful work when waiting for a database response. The question becomes how much?</p>
<p>This is dependent on the overhead that asyncio imposes. If the asyncio event loop, and associated Python code required to schedule coroutines, is slow then it&#39;ll defeat the purpose.</p>
<p>Libraries such as uvloop are important in this regard, since they offer a faster event loop implemention, which is still compatible with asyncio.</p>
<h2 id="why-use-this-and-not-node-or-go-">Why use this, and not Node or Go?</h2>
<p>Up until ...</p>
