<h1 id="why-choose-piccolo-">Why choose Piccolo?</h1>
<p>Here&#39;s an overview of three of the most popular Python ORMs:</p>
<h2 id="sqlalchemy">SQLAlchemy</h2>
<p>Advantages:</p>
<ul>
<li>The swiss army knife of ORMs - supports a lot of database features.</li>
<li>Automatic migrations</li>
<li>Standalone</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Steep learning curve</li>
</ul>
<h2 id="django">Django</h2>
<p>Advantages:</p>
<ul>
<li>Automatic migrations</li>
<li>Easy to learn the basics, but surprising depth</li>
<li>Integration with testing framework</li>
<li>Admin integration</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Tricky to use it standalone.</li>
<li>Some unintuitive syntax, such as group by.</li>
</ul>
<h2 id="peewee">Peewee</h2>
<p>Advantages:</p>
<ul>
<li>Simple</li>
<li>Standalone</li>
</ul>
<p>Downsides:</p>
<ul>
<li>Limited migration support (not automatic)</li>
</ul>
<h2 id="piccolo">Piccolo</h2>
<p>The main reason you&#39;d pick Piccolo is if you need asyncio support. The Django ORM is the only one which might support this in the future, but traditionally it has been hard to use the Django ORM in a standalone project.</p>
<p>It&#39;s more akin to Django and Peewee in terms of syntax, and prioritises ease of use over supporting a large number of databases and features. It attempts to cover 90% of queries you&#39;re likely to do on a database, and encourages you to drop down to SQL when required.</p>
<p>The syntax attempts to be as close to SQL as possible. This lessens the learning curve for people with SQL experience, and means they won&#39;t have to learn a bunch of new abstractions on top of something they&#39;re already familiar with.</p>
